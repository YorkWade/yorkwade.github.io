---
layout:     post
title:      muduo阅读笔记之第4章
subtitle:   C++多线程系统编程精要
date:       2018-03-15
author:     BY
header-img: img/post-bg-BJJ.jpg
catalog: true
tags:
    - BJJ
---

### 多线程编程的思维方式转变：

    1、当前线程可能随时被切换出去。
    2、多线程程序中事件的发生顺序不再有先后关系（除非引入适当同步）。
### 使用11个基本的线程原语

    2个：线程创建和等待结束（join）
    4个：mutex的创建、销毁、加锁、解锁
    5个：条件变量的创建、销毁、等待、通知、广播。
不推荐读写锁原因，造成提高性能的错觉（多个线程并发读），实际上比使用最简单的mutex相比，实际上降低了性能。另外，写操作会阻塞读操作，如果要求优化读操作的延迟，读写锁是不合适的。</br>
### C/C++系统库的线程安全性</br>
       “纯函数”不收影响（如memset/strcpy,snprintf）</br>
有些影响全局状态或者有副作用的函数，需要加锁才能线程安全。</br>
glibc库函数大部分是线程安全的。特别是FILE*系列函数是安全的。除了：system、getenv/puenv/setenv等非线程安全函数。</br>
    系统调用对于用户态程序是原子的，但是要注意系统调用对于内和状态的改变可能会影响其他线程。编写线程安全程序的一个难点在于线程安全是不可组合的。一个函数调用了两个线程安全的函数，但该函数本身很可能不是线程安全的。</br>
    C++标准库容器和std::string都不是线程安全的。绝大多数泛型算法是线程安全的(无状态纯函数)。iostream不是线程安全的。
原则：共享对象的read-only操作是安全的。两个线程访问共享的vector对象，但这个vector不能被第三个线程修改，一旦有writer，那么read-only必须加锁，例如vector::size()</br>
linux上的线程标识</br>
    Pthread提供的pthread_self函数返回的pthread_t是结构体类型，对于打印日志、hash的key，等都不方便。自己实现。建议使用gettid(2)系统调用作为线程id。线程中频繁打印日志，使用pid，采用__thread变量缓存gettid(2)

### 线程的创建销毁原则
#### 创建：</br>
    
    1、程序不应该在未提前告知的情况下创建自己的背景线程。可能会高估系统可用的资源，影响性能。
    2、尽量使用相同的方式创建线程。可以统一记录、管理、统计。但不是总能做到的（第三方库有自己的线程）。
    3、在进入main前，不应该启动线程。影响全局对象的安全构造。如果线程使用了未初始化的全局变量，无法线程安全，很尴尬。
    4、程序中创建最好能在初始化阶段全部完成。

全局变量在main前构造，各个编译单元的对象构造顺序不定（有办法影响初始化顺序），但都在主线程完成，无需考虑线程安全。
#### 销毁：</br>
    
    线程正常退出的方式只有一种，即从线程主函数返回。
    非正常死亡（pthread_cancel、pthread_exit、或者在线程主函数中抛出异常或信号等），会使线程没有机会清理资源（如没机会释放mutex、造成死锁。）
    thread对象的生命期应长于线程。
    如果线程的创建在初始化阶段全部完成，则线程不必销毁，伴随进程一直运行，避免thread对象生命期管理、资源释放等困难。
### exit在c++中不是线程安全的</br>
    exit除了终止进程，还会析构全局对象和已经构造完的函数静态对象。可能会造成死锁，或者崩溃。</br>
    用全局对象实现无状态策略，析构是危险的。</br>
善用__thread关键字</br>

    __thread是GCC内置的线程局部存储设施。__thread变量是每个线程有一份实体，各个线程的变量值互不干扰。
    __thread使用规则：
    
        只能修饰POD类型，不能修饰class类型，因此不能自动调用构造析构。
        可以修饰全局变量、函数内部的静态比昂量，不能修饰函数的局部变量和class的普通成员变量。
        __thread修饰变量的初始化只能用于编译期的常量。</br>
### 多线程与IO
    操作文件描述符的系统调用是线程安全的。    
    多个线程同时操作同一个socket文件描述符，可能程序逻辑设计有问题，应该同一个线程操作此socket。
    多线程磁盘IO的一个思路是每个磁盘配一个线程，避免或减少内和中的锁争用。每块磁盘都有一个操作队列，多个线程读写请求到了内核是排队执行的。
    原则：  每个文件描述符只由一个线程操作，解决了消息收发的顺序性问题，也避免了关闭文件描述符的各种race condition。
    epoll fd操作（添加、删除、修改、等待）也应该都放到同一个线程中执行。
### 用RAII包装文件描述符
    POSIX分配文件描述（每次打开文件，使用当前最小可用的文件描述符号码），可能会造成串话。如：一个线程read某个socket，第二个线程close socket,第三个线程又open了另一个文件描述符，其号码刚好与前面的socket相同。第一个线程可能读到了本应该第三个线程使用的数据。
    解决方法：  使用RAII包装文件描述符。只要socket对象活着，就不会有同样的文件描述符。用shared_ptr管理socket对象。
### fork可能出现问题
    fork之后，子进程继承了父进程的几乎全部状态，但只有一个线程（只能克隆当前县城的thread of control，不克隆其他线程。），不会继承：父进程的内存锁（mlock、mlockall）、文件锁（fcntl）、定时器（setitimer）
### 避免使用signal

## 我的总结：

    1、 glibc库函数大部分是线程安全的，操作文件描述符的系统调用是线程安全的。 
    2、C++标准库容器和std::string都不是线程安全的。绝大多数泛型算法是线程安全的。iostream不是线程安全的。
    3、一个函数调用了两个线程安全的函数，但该函数本身很可能不是线程安全的。
    4、程序中线程的创建在main之前，最好能在初始化阶段全部完成
    5、线程正常退出的方式只有一种，即从线程主函数返回。
    6、每个文件描述符只由一个线程操作。
    7、POSIX分配文件描述，可能会造成串话。正确方法，使用RAII包装文件描述符，用shared_ptr管理描述符对象。
