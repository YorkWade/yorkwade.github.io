---
layout:     post
title:      Actor
subtitle:   并发模式
date:       2020-03-03
author:     BY
header-img: img/post-bg-ios9-web.jpg
catalog: true
tags:
    - Actor
---

> 不要以共享内存方式通信，要以通信方式共享内存




# Actor的实现要点

- 如何保证同一Actor线程安全
- 如何防止线程饿死
- 如何优化，减少或避免不必要的消息复制

## Actor线程安全
- 全局消息队列，供线程池消费。
- 局部消息队列，供单个线程消费。

## 防止线程饿死
- 如发现线程饿死，动态创建线程
- 根据线程权重（队列累积的消息的多少），处理不同个数的消息。

## 如何优化

- 消息使用引用计数（智能指针），传递只传递指针。
- 如果处理消息的线程，又发送消息，在该线程的LocalQueue中投递消息并处理。
- 队列使用循环双列表

# 前言



CSP的模式比较适合Boss-Worker模式的任务分发机制，它的侵入性没那么强，可以在现有的系统中通过CSP解决某个具体的问题。它并不试图解决通信的超时容错问题，这个还是需要发起方进行处理。同时由于Channel是显式的，虽然可以通过netchan（原来Go提供的netchan机制由于过于复杂，被废弃，在讨论新的netchan）实现远程Channel，但很难做到对使用方透明。
而Actor则是一种全新的抽象，使用Actor要面临整个应用架构机制和思维方式的变更。它试图要解决的问题要更广一些，比如容错，比如分布式。但Actor的问题在于以当前的调度效率，哪怕是用Goroutine这样的机制，也很难达到直接方法调用的效率。当前要像OO的『一切皆对象』一样实现一个『一切皆Actor』的语言，效率上肯定有问题。所以折中的方式是在OO的基础上，将系统的某个层面的组件抽象为Actor。


   对于某个 Actor 我们可以为某个消息类型注册多个消息处理函数，那么此消息类型对应的多个消息处理函数会按照注册的顺序被串行执行下去
   
   线程按顺序处理 Actor 收到的消息，一个消息未处理完成不会处理消息队列中的下一个消息 我们可以想象，如果存在三个 Actor，其中两个 Actor 的消息处理函数中存在死循环（例如上例中的 while(true)），那么它们一旦执行就会霸占两条线程，若线程池中没有多余线程，那么另一个 Actor 将被“饿死”（永远得不到执行）。我们可以在设计上避免这种 Actor 的出现，当然也可以适当的调整线程池的大小来解决此问题。Theron 中，线程池中线程的数量是可以动态控制的，线程利用率也可以测量。但是务必注意的是，过多的线程必然导致过大的线程上下文切换开销。
   
   和传统的多线程程序相比 Theron 有不少优势，通过使用 Actor，程序能够自动的并行执行，而无需开发者费心。Actor 总是利用消息进行通信，消息必须拷贝，这也意味着我们必须注意到，在利用 Actor 进行并行运算的同时需避免大量消息拷贝带来的额外开销。
   
   Actor 模型强调了一切皆为 Actor，这自然可以作为我们使用 Theron 的一个准则。但过多的 Actor 存在必然导致 Actor 间频繁的通信。适当的使用 Actor 并且结合 Object 模型也许会是一个不错的选择，例如，我们可以对系统进行适当划分，得到一些功能相对独立的模块，每个模块为一个 Actor，模块内部依然使用 Object 模型，模块间通过 Actor 的消息机制进行通信。
   
1.调度思路：
在 Skynet 启动时，建立了若干 工作线程（数量可配置），它们不断的从主消息列队中取出一个次级消息队列来，再从次级队列中取去一条消息，调用对应的服务的 callback 函数进行处理。为了调用公平，一次仅处理一条消息，而不是耗净所有消息（虽然那样的局部效率更高，因为减少了查询服务实体的次数，以及主消息队列进出的次数），这样可以保证没有服务会被饿死（饿死 指的是得不到工作线程执行的机会）。这样，skynet就实现了把一个消息（数据包）从一个服务发送给另一个服务。

全局队列是一个用固定大小的数组模拟的循环队列，此循环队列向尾部添加，从头部删除，分别用head、tail记录其首尾下标。
全局队列保存所有的服务队列，worker线程向全局队列索取服务队列。为了效率，并不是简单的把所有的服务队列都塞到全局队列中，而是只塞入非空的服务队列，这样worker线程就不会得到空的服务队列而浪费资源。
由于工作线程有多个，为了避免冲突，Skynet运用了这样的策略：每次worker线程取得一个服务队列的时候，都把这个服务队列从全局队列中删除，这样其他的worker线程就没法获取到这个服务队列了，当此worker线程操作完毕后，再将此服务队列添加到全局队列（若服务队列非空的话）。

# 参考

- [关于并发模型 Actor 和 CSP](https://blog.csdn.net/hotdust/article/details/72475630)
- [并发之痛 Thread，Goroutine，Actor](http://jolestar.com/parallel-programming-model-thread-goroutine-actor/)
- [通过Actor模型解决C++ 并发编程的一种思维 — Theron 库简述](https://blog.csdn.net/sigh667/article/details/76438785)
- [Skynet服务器框架（八） 任务和消息调度机制](https://blog.csdn.net/linshuhe1/article/details/73854411)
- [Skynet之消息队列 - 消息的存储与分发](https://www.cnblogs.com/freebird92/p/6435212.html)


